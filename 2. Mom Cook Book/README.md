# The Mom's Cook Book

Mom's Cook Book is a web application that allows you to search over 1,000,000 (and more) recipes from your past.

## 1. Features

- **Search Functionality**: Users can search for their desired recipes from my Mom's Cook Book of over 1,000,000 recipes.
- **Generating the list of found recipes**: The application displays a list of found recipes based on the user's search query with nise pagination buttons.
- **Pagination**: The application displays a list of found recipes with pagination buttons.
- **Recipe preselection highlighting**: Moved mouse highlights the item from the list.
- **Showing recipie details**: The application displays the details of a recipe, including the ingredients, servings, and cooking instructions.
- **Adding to bookmarks**: Users can add recipes to their bookmarks for easy access later.
- **Adjusting servings**: Users can adjust the number of servings for a recipe, and the application will automatically update the ingredient quantities.
- **Adding a new recipe**: Users can add a new recipe to the database.
- **Responsive Design**: The application is designed to be responsive and can be used on devices of different sizes.
- **Modern UI**: The application uses a modern and clean user interface for easy navigation.
- **Scalable Architecture**: The application is built with scalability in mind, allowing for easy addition of new features.

## 2. Code Structure

All the code is organized into different files and folders based on their functionality.
- folder `img`: contains all the images used in the application.'
- folder `sass`: contains all the styles used in the application.
- folder `js`: contains all the javascript files used in the application.
- file `index.html`: The main HTML file for the application.
- file `package.json`: The file contains the application's metadata and dependencies.
- file `package-lock.json`: This file is automatically generated for any operations where npm modifies either the node_modules tree or package.json.
- 
The best MVC (Model-View-Controller) practices are used in the application. All models, views, and controllers - the core of the project is stored in the JavaScript folder js. The main files are:
- `model.js`: This model file contains the application state and functions to manipulate it. It handles data fetching, updating servings, and managing bookmarks.
- `controller.js`: This controller file is responsible for rendering the recipe view and handling user interactions such as updating servings and adding bookmarks.
- `config.js`: This file contains configuration constants for the application, such as the API URL and API key.
- `helpers.js`: This file contains helper functions for making AJAX requests and formatting data.
- the folder `views` contains the base class for creating views:
- `View.js`: This file contains a base class for creating views. It contains methods for rendering and updating the view based on the application state.
- `addRecipeView.js`: This file contains the view for rendering the add recipe form.
- `bookmarksView.js`: This file contains the view for rendering the bookmarks list.
- `paginationView.js`: This file contains the view for rendering the pagination buttons.
- `previewView.js`: This file contains the view for rendering the recipe preview.
- `recipeView.js`: This file contains the view for rendering the recipe details.
- `resultsView.js`: This file contains the view for rendering the list of found recipes.
- `searchView.js`: This file contains the view for rendering the search bar and search results.

The Publisher-Subscriber pattern, also known as the Pub-Sub pattern, also actively was implemented during event handling of the functional logic

Pub-Sub used is commonly used in software architecture, where initiator of events (publishers) do not program the messages to be sent directly to specific receivers (subscribers). 

Instead, the events are categorized into classes without knowledge of which subscribers, if any, there may be.

In the provided code, the Pub-Sub pattern is used to handle user interactions and update the application state. Here's how it works:

1. The `controller.js` file acts as the publisher. When a user interacts with the application (for example, by clicking a button), the controller dispatches an event.

2. The `model.js` file acts as the subscriber. It listens for these events and updates the application state accordingly. For example, when a user clicks the "update servings" button, the controller dispatches an event that triggers the `updateServings` function in the model.

3. All views in the `Views` folder and its subclasses (like `RecipeView`) also act as subscribers. They listen for changes in the application state and update the view accordingly. For example, when the application state changes, the `RecipeView` re-renders the recipe details based on the new state.

This pattern allows for a clear separation of concerns in the application. The controller only needs to know how to dispatch events, the model only needs to know how to update the state, and the views only need to know how to render themselves based on the state. This makes the code easier to understand, test, and maintain.

## 4. App Usage

To use the application, simply type this desired recipe type (pizza, soup ...) into the search bar and press enter. The application will fetch the recipes list from the query and display it on the page. 
Then you can click on the recipe to see the details. You can also adjust the number of servings and add the recipe to this bookmarks.

If you like it, you can add this recipe to this bookmarks by clicking on the heart icon. You can also add this own recipe by clicking on the "Bookmark" button.
From the bookmarks, you can retrieve the recipe by clicking on the recipe name.

If you want to add a new recipe, click on the "Add Recipe" button and fill in the form. The Recipe will be added to the database.

## 5. Page Data States

In a web application, data states refer to the different conditions or configurations that the application's data can be in at any given time. This data is often stored in objects or variables and can include things like user input, fetched data from an API, or UI state.

In this case, the data state is managed in the `model.js` file. The `data` object holds the current state of the application, including the current recipe, search results, and bookmarks. This state is updated in response to user interactions and data fetched from the API.

Here's a brief overview of the main parts of the state:

- `recipe`: This is an object that holds the details of the currently selected recipe. It includes properties like `id`, `title`, `publisher`, `sourceUrl`, `image`, `servings`, `cookingTime`, and `ingredients`.

- `search`: This is an object that holds the state of the search feature. It includes properties like `query` (the current search query), `results` (the search results), `page` (the current page of search results), and `resultsPerPage` (the number of results to show per page).

- `bookmarks`: This is an array that holds the recipes that the user has bookmarked.

The state is updated in response to user interactions, such as searching for a recipe, selecting a recipe, updating the number of servings, or adding a recipe to the bookmarks. When the state changes, the views are updated to reflect the new state. For example, when the `recipe` state changes, the `RecipeView` re-renders the recipe details based on the new state.

This approach of managing state makes it easier to keep the UI in sync with the underlying data. It also makes the code easier to understand, test, and maintain, as each part of the application has a clear responsibility: the model manages the state, the views render the UI based on the state, and the controller handles user interactions and updates the state.


## 5. Data Flow

In the provided code, the data flow is unidirectional and follows the Model-View-Controller (MVC) pattern. Here's a step-by-step description of how the data flows in the application:

1. **User Interaction**: The data flow starts with a user interaction, such as searching for a recipe, selecting a recipe, updating the number of servings, or adding a recipe to the bookmarks. These interactions are handled by the controller (`controller.js`).

2. **Event Dispatch**: In response to the user interaction, the controller dispatches an event. This event contains information about the interaction, such as the id of the selected recipe or the new number of servings.

3. **State Update**: The dispatched event is then handled by the model (`model.js`). The model contains functions that listen for these events and update the application state accordingly. For example, if the user selects a recipe, the `loadRecipe` function in the model is triggered, which fetches the recipe details from the API and updates the `recipe` state.

4. **View Update**: Once the state has been updated, the views (`View.js` and its subclasses like `RecipeView`) re-render themselves based on the new state. For example, if the `recipe` state changes, the `RecipeView` re-renders the recipe details based on the new state.

5. **UI Update**: The updated views are then displayed to the user. This completes the data flow cycle. The next cycle will start with the next user interaction.

This unidirectional data flow makes the code easier to understand and debug, as it's always clear where the data is coming from and where it's going. It also ensures that the UI stays in sync with the underlying data.

## 6. External API (recipies database)

The application uses a RESTful API to fetch recipe data. REST stands for Representational State Transfer, and it's a set of architectural principles for designing networked applications. A RESTful API uses HTTP methods to perform operations on resources, which are identified by URLs.

In the provided code, the API is used in the `model.js` file. Here's a brief overview of how it's used:

- **API URL and Key**: The API URL and key are stored in the `config.js` file. The URL is the base URL for the API, and the key is used to authenticate requests.

- **Fetching a Recipe**: The `loadRecipe` function fetches the details of a specific recipe. It sends a GET request to the API with the recipe ID as a parameter. The API responds with the recipe details, which are then stored in the `recipe` state.

- **Searching for Recipes**: The `loadSearchResults` function fetches a list of recipes based on a search query. It sends a GET request to the API with the search query as a parameter. The API responds with a list of matching recipes, which are then stored in the `search.results` state.

- **Updating a Recipe**: The `uploadRecipe` function adds a new recipe to the database. It sends a POST request to the API with the recipe details as the request body. The API responds with the details of the added recipe, which are then stored in the `recipe` state.

The API uses standard HTTP status codes to indicate the success or failure of a request. For example, a status code of 200 indicates a successful request, while a status code of 404 indicates that the requested resource could not be found.

The API also returns data in JSON format, which is a lightweight data-interchange format that's easy to read and write. The application uses the `JSON.parse` method to parse the JSON data into a JavaScript object, which can then be used to update the application state.

## 7. Asynchronous JavaScript (AJAX)
In the provided code, asynchronous fetching is used to retrieve data from the API. This is done using the `fetch` API, which returns a Promise that resolves to the Response object representing the response to the request. This is an asynchronous operation, meaning it allows the JavaScript runtime to continue executing other code while it waits for the fetch to complete.

In the `model.js` file, the `AJAX` function from `helpers.js` is used to perform the asynchronous fetch operation. This function uses the `fetch` API to send a request to the API and returns a Promise that resolves to the JSON data from the response.

Here's a brief overview of how asynchronous fetching is used in the code:

- **Fetching a Recipe**: The `loadRecipe` function fetches the details of a specific recipe. It uses the `AJAX` function to send a GET request to the API with the recipe ID as a parameter. This is an asynchronous operation, so the `await` keyword is used to pause execution of the function until the Promise resolves. Once the Promise resolves, the function continues execution and the recipe details are stored in the `recipe` state.

- **Searching for Recipes**: The `loadSearchResults` function fetches a list of recipes based on a search query. It uses the `AJAX` function to send a GET request to the API with the search query as a parameter. This is also an asynchronous operation, so the `await` keyword is used to pause execution of the function until the Promise resolves. Once the Promise resolves, the function continues execution and the search results are stored in the `search.results` state.

- **Updating a Recipe**: The `uploadRecipe` function adds a new recipe to the database. It uses the `AJAX` function to send a POST request to the API with the recipe details as the request body. This is an asynchronous operation, so the `await` keyword is used to pause execution of the function until the Promise resolves. Once the Promise resolves, the function continues execution and the details of the added recipe are stored in the `recipe` state.

By using asynchronous fetching, the application can retrieve data from the API without blocking the JavaScript runtime, allowing for a smoother user experience.

## 8. Parcel

In this project, Parcel was used to serve the application during development. When you run `npm start`, it starts the Parcel development server. This server compiles this code and serves it at a local URL, usually `http://localhost:1234`. It also watches this files for changes and automatically recompiles this code and refreshes the page when you save a file.

Parcel is a web application bundler that I was using in this project. It's a tool that takes this code, along with all its dependencies, and bundles it into a single file that can be served to the browser. It's similar to other tools like Webpack or Rollup, but it's designed to work out of the box with zero configuration.

Here's the command that's being run when app to be executed `npm start`:

```bash
parcel index.html
```
of just `npm start` which is a shorthand for the above command.

This command tells Parcel to start bundling this application starting from the `index.html` file. Parcel analyzes this file, finds all the linked JavaScript and CSS files, and starts bundling them together. It also starts a development server and serves the bundled files.

Parcel supports many different file types out of the box, including JavaScript, CSS, HTML, and more. It also has built-in support for transformations with Babel, PostCSS, and PostHTML. And it automatically optimizes this assets for production when you build this application for deployment.


## 9. Installation

To get a local copy up and running follow these simple steps:
**Install dependencies** `npm install`
**Start the server** `npm start`

## 10. The room for improvement
While the project is well-structured and implements a lot of functionality, there are always areas that can be improved or expanded upon. Here are a few suggestions:

1. **Error Handling**: While the code does have some error handling in place, it could be improved. For example, the application could provide more user-friendly error messages when a network request fails or when an invalid input is entered.

2. **Testing**: The project could benefit from a more comprehensive suite of automated tests. This could include unit tests for individual functions, integration tests for larger pieces of functionality, and end-to-end tests that simulate user interactions.

3. **Performance Optimization**: There may be opportunities to optimize the performance of the application. This could involve things like lazy-loading images, minifying and compressing JavaScript and CSS files, and using a service worker to cache assets for offline use.

4. **Accessibility**: It's important to ensure that web applications are accessible to all users, including those with disabilities. The application could be improved by adding ARIA attributes, ensuring sufficient color contrast, and providing keyboard navigation.

5. **User Interface**: While the user interface is clean and modern, there's always room for improvement. This could involve tweaking the color scheme, improving the layout on smaller screens, or adding animations and transitions for a more polished look and feel.

6. **Additional Features**: Depending on the needs of the users, there could be several features to add. For example, a rating system for recipes, comments section, or the ability to share recipes on social media.

Remember, it's important to prioritize these improvements based on the needs of the users and the goals of the project.